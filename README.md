# Route Impression Calculator

A web application that calculates advertising impressions generated by vehicles as they pass through geofenced campaign areas. Built with Node.js, Express, React, and TypeScript.

## Quick Start

### Prerequisites
- Node.js 18+ 
- npm

### Installation and Setup

1. Clone this repository
```bash
git clone <repository-url>
cd route-impression-calculator
```

2. Install dependencies
```bash
npm install
```

3. Start the development servers
```bash
npm run dev
```

This will start:
- Backend API server on http://localhost:4000
- Frontend React app on http://localhost:5173

### Running Tests

```bash
# Run all tests
npm test

# Run backend tests only
npm run test --workspace=backend

# Run frontend tests only  
npm run test --workspace=frontend
```

### Building for Production

```bash
npm run build
```

## API Documentation

### POST /api/calculate

Calculates impressions for vehicles passing through campaign geofences.

#### Request Body

```json
{
  "markets": [
    {
      "marketId": "LA",
      "impressionsPerMinute": 1200
    }
  ],
  "campaigns": [
    {
      "campaignId": "camp_001", 
      "marketId": "LA",
      "geofence": {
        "minLon": -118.5,
        "maxLon": -118.2, 
        "minLat": 34.0,
        "maxLat": 34.2
      }
    }
  ],
  "routes": [
    {
      "routeId": "route_001",
      "campaignId": "camp_001",
      "pings": [
        {
          "timestamp": "2025-01-15T10:00:00Z",
          "lon": -118.25,
          "lat": 34.05
        },
        {
          "timestamp": "2025-01-15T10:02:30Z", 
          "lon": -118.30,
          "lat": 34.10
        }
      ]
    }
  ],
  "options": {
    "returnIntervals": false
  }
}
```

#### Response Body

```json
{
  "summary": {
    "totalImpressions": 2400,
    "totalSecondsInside": 120,
    "routeCount": 1,
    "campaignCount": 1
  },
  "campaigns": [
    {
      "campaignId": "camp_001",
      "marketId": "LA", 
      "impressionsPerMinute": 1200,
      "totalSecondsInside": 120,
      "totalImpressions": 2400,
      "routes": [
        {
          "routeId": "route_001",
          "secondsInside": 120,
          "impressions": 2400,
          "entries": 1,
          "exits": 0
        }
      ]
    }
  ],
  "assumptions": [
    "Linear movement between consecutive pings",
    "Planar approximation for lat/lon coordinates"
  ],
  "limitations": [
    "Only supports rectangular geofences",
    "Large gaps between pings may reduce accuracy"
  ]
}
```

### Sample cURL Request

```bash
curl -X POST http://localhost:4000/api/calculate \
  -H "Content-Type: application/json" \
  -d '{
    "markets": [
      {"marketId": "LA", "impressionsPerMinute": 1200},
      {"marketId": "NYC", "impressionsPerMinute": 1500}
    ],
    "campaigns": [
      {
        "campaignId": "camp_001",
        "marketId": "LA", 
        "geofence": {"minLon": -118.5, "maxLon": -118.2, "minLat": 34.0, "maxLat": 34.2}
      },
      {
        "campaignId": "camp_002", 
        "marketId": "NYC",
        "geofence": {"minLon": -74.1, "maxLon": -73.9, "minLat": 40.7, "maxLat": 40.8}
      }
    ],
    "routes": [
      {
        "routeId": "route_001",
        "campaignId": "camp_001",
        "pings": [
          {"timestamp": "2025-01-15T10:00:00Z", "lon": -118.6, "lat": 34.1},
          {"timestamp": "2025-01-15T10:01:00Z", "lon": -118.4, "lat": 34.1}, 
          {"timestamp": "2025-01-15T10:02:00Z", "lon": -118.3, "lat": 34.1},
          {"timestamp": "2025-01-15T10:03:00Z", "lon": -118.1, "lat": 34.1}
        ]
      },
      {
        "routeId": "route_002",
        "campaignId": "camp_002", 
        "pings": [
          {"timestamp": "2025-01-15T11:00:00Z", "lon": -74.0, "lat": 40.75},
          {"timestamp": "2025-01-15T11:01:00Z", "lon": -73.95, "lat": 40.76}
        ]
      }
    ]
  }'
```

#### Sample Response

```json
{
  "summary": {
    "totalImpressions": 1650,
    "totalSecondsInside": 90, 
    "routeCount": 2,
    "campaignCount": 2
  },
  "campaigns": [
    {
      "campaignId": "camp_001",
      "marketId": "LA",
      "impressionsPerMinute": 1200, 
      "totalSecondsInside": 60,
      "totalImpressions": 1200,
      "routes": [
        {
          "routeId": "route_001",
          "secondsInside": 60,
          "impressions": 1200,
          "entries": 1,
          "exits": 1
        }
      ]
    },
    {
      "campaignId": "camp_002", 
      "marketId": "NYC",
      "impressionsPerMinute": 1500,
      "totalSecondsInside": 30,
      "totalImpressions": 750,
      "routes": [
        {
          "routeId": "route_002",
          "secondsInside": 30, 
          "impressions": 750,
          "entries": 1,
          "exits": 0
        }
      ]
    }
  ]
}
```

## Architecture Overview

### Backend Services

The backend is organized into focused modules:

- **Express Server** (`src/index.ts`): Main application entry point with CORS and routing
- **Zod Schemas** (`src/schemas.ts`): Request/response validation and TypeScript types  
- **Geometry Module** (`src/geometry/`): Spatial calculations and line clipping
- **Calculation Module** (`src/calc/`): Core business logic for time attribution and impressions
- **API Routes** (`src/routes/`): HTTP request handlers

### Core Algorithm

The system uses the **Liang-Barsky line clipping algorithm** to determine what fraction of each route segment (between consecutive GPS pings) falls inside rectangular geofences.

#### Key Components

1. **Rectangle Intersection** (`geometry/rectangle.ts`): Point-in-rectangle tests
2. **Line Segment Clipping** (`geometry/segmentClip.ts`): Liang-Barsky implementation returning fraction inside geofence
3. **Time Attribution** (`calc/attribution.ts`): Distributes time between pings based on inside fraction
4. **Impression Calculation** (`calc/impressions.ts`): Converts dwell time to impressions using market rates

#### Algorithm Steps

1. **Parse Input**: Validate markets, campaigns, and routes using Zod schemas
2. **Sort Pings**: Ensure timestamps are chronologically ordered 
3. **Process Route Segments**: For each pair of consecutive pings:
   - Calculate time interval in seconds
   - Use Liang-Barsky to find fraction of line segment inside geofence
   - Attribute time: `timeInside = intervalSeconds * insideFraction`
4. **Calculate Impressions**: `impressions = timeInside * (impressionsPerMinute / 60)`
5. **Detect Entry/Exit Events**: Track transitions across geofence boundaries
6. **Aggregate Results**: Sum impressions across routes and campaigns

### Frontend Architecture

- **React + Vite + TypeScript**: Modern frontend stack
- **Component Structure**: 
  - `App.tsx`: Main application with tab navigation
  - `DataInput.tsx`: File upload and JSON text input
  - `Results.tsx`: Display calculated impressions with detailed breakdowns
  - `ImpressionsChart.tsx`: Bar chart visualization using Recharts
- **State Management**: React hooks for local state
- **API Integration**: Fetch API for backend communication
- **Toast Notifications**: User feedback for actions and errors

## Assumptions

1. **Linear Movement**: Vehicles travel in straight lines between GPS pings
2. **Planar Approximation**: Lat/lon coordinates treated as Cartesian for city-scale distances (acceptable error for urban areas)
3. **Constant Speed**: Time is distributed linearly along route segments
4. **Rectangular Geofences**: Only axis-aligned rectangles supported (specified in requirements)
5. **Sorted Timestamps**: GPS pings are automatically sorted if provided out of order

## Known Limitations

1. **Geofence Shapes**: Only rectangular (axis-aligned) geofences supported
2. **GPS Accuracy**: No consideration for GPS noise, accuracy, or smoothing
3. **Projection**: No map projection used - may introduce small errors over large distances
4. **Route Gaps**: Large time gaps between pings reduce interpolation accuracy
5. **Speed Variations**: Assumes constant speed between pings (no acceleration/deceleration)
6. **Real-time**: Not designed for real-time streaming data

## If I Had More Time

### Enhanced Geometry
- **Polygon Geofences**: Support arbitrary polygon shapes using point-in-polygon algorithms
- **Map Projections**: Use proper cartographic projections (UTM/State Plane) for accuracy
- **Curved Routes**: Account for road network topology and realistic vehicle paths

### Advanced Analytics  
- **Speed Analysis**: Detect stops, acceleration, and speed-based impression weighting
- **GPS Filtering**: Kalman filtering for noisy GPS data
- **Route Optimization**: Suggest optimal routes for maximum impression generation

### Visualization & UX
- **Interactive Maps**: Leaflet/Mapbox integration showing routes and geofences
- **Real-time Dashboard**: Live tracking with WebSocket updates
- **Export Features**: CSV/PDF report generation
- **Bulk Operations**: Process multiple files and campaigns simultaneously

### Performance & Scale
- **Database Integration**: PostgreSQL with PostGIS for spatial queries
- **Caching**: Redis for frequently accessed calculations
- **Streaming**: Handle large datasets with stream processing
- **API Rate Limiting**: Production-ready rate limiting and authentication

### Testing & Monitoring
- **Integration Tests**: End-to-end API testing
- **Performance Tests**: Load testing with realistic datasets  
- **Monitoring**: Prometheus metrics and health checks
- **Error Tracking**: Sentry integration for production monitoring

## Development Time

**Approximate time spent: 4-5 hours**

- Project setup and architecture: 30 minutes
- Backend implementation (API, algorithms, tests): 2 hours  
- Frontend implementation (React components, styling): 1.5 hours
- Integration, testing, and documentation: 1 hour

The modular architecture allows for easy extension and the comprehensive test suite ensures reliability for production use.